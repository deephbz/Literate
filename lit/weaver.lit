@code_type d .d
@comment_type // %s
@compiler make debug -C ..
@error_format .*/%f\(%l,%s\):%s: %m

@title Weaver

@s Introduction

Here is an overview of the weave program. This file turns a literate source
file into one or more html files.

--- weaver.d
@{Imports}

void weave(Program p) {
    @{Parse use locations}
    @{Run weaveChapter}
    if (isBook && !noOutput) {
@{Create the table of contents}
    }
}

@{WeaveChapter}
@{LinkLocations function}
---

@s Parsing Codeblocks

Now we parse the codeblocks across all chapters in the program. We
have four arrays:

* defLocations: stores the section in which a codeblock is defined.
* redefLocations: stores the sections in which a codeblock is redefined.
* addLocations: stores the sections in which a codeblock is added to.
* useLocations: stores the sections in which a codeblock is used;

--- Parse use locations
string[string] defLocations;
string[][string] redefLocations;
string[][string] addLocations;
string[][string] useLocations;

foreach (chapter; p.chapters) {
    foreach (s; chapter.sections) {
        foreach (block; s.blocks) {
            if (block.isCodeblock) {
                if (block.modifiers.canFind(Modifier.noWeave)) {
                    defLocations[block.name] = "noWeave";
                    continue;
                }

                @{Check if it's a root block}

                if (block.modifiers.canFind(Modifier.additive)) {
                    if (block.name !in addLocations || !addLocations[block.name].canFind(to!string(s.num)))
                        addLocations[block.name] ~= chapter.num() ~ ":" ~ to!string(s.num);
                } else if (block.modifiers.canFind(Modifier.redef)) {
                    if (block.name !in redefLocations || !redefLocations[block.name].canFind(to!string(s.num)))
                        redefLocations[block.name] ~= chapter.num() ~ ":" ~ to!string(s.num);
                } else {
                    defLocations[block.name] = chapter.num() ~ ":" ~ to!string(s.num);
                }

                foreach (lineObj; block.lines) {
                    string line = strip(lineObj.text);
                    if (line.startsWith("@{") && line.endsWith("}")) {
                        useLocations[line[2..$ - 1]] ~= chapter.num() ~ ":" ~ to!string(s.num);
                    }
                }
            }
        }
    }
}
---

Here we simply loop through all the chapters in the program and get the html for them.
If `noOutput` is false, we generate html files in the `outDir`.

--- Run weaveChapter
foreach (c; p.chapters) {
    string output = weaveChapter(c, p, defLocations, redefLocations,
                                 addLocations, useLocations);
    if (!noOutput) {
        string dir = outDir;
        if (isBook) {
            dir = outDir ~ "/_book";
            if (!dir.exists()) {
                mkdir(dir);
            }
        }
        File f = File(dir ~ "/" ~ stripExtension(baseName(c.file)) ~ ".html", "w");
        f.write(output);
        f.close();
    }
}
---

@s Table of contents

If the program being compiled is a book, we should also write a table of contents file.

--- Create the table of contents
string dir = outDir ~ "/_book";
File f = File(dir ~ "/" ~ p.title ~ "_contents.html", "w");
f.writeln(
q"DELIMITER
<!DOCTYPE html>
<html>
<head>
<style>
@include ./weaver_static/toc_styles.css
</style>
</head>
<body>
<div class="container">
DELIMITER"
);

f.writeln("<h1>" ~ p.title ~ "</h1>");

string html;
string md = p.text;
if (useMdCompiler) {
    auto pipes = pipeShell(mdCompilerCmd, Redirect.stdin | Redirect.stdout | Redirect.stderrToStdout);
    pipes.stdin.write(md);
    pipes.stdin.flush();
    pipes.stdin.close();
    auto status = wait(pipes.pid);
    string mdCompilerOutput;
    foreach (line; pipes.stdout.byLine) mdCompilerOutput ~= line.idup;
    if (status != 0) {
        warn(p.file, 1, "Custom markdown compilation failed: " ~ mdCompilerOutput ~ " -- Falling back to built-in markdown compiler");
        html = filterMarkdown(md, MarkdownFlags.disableUnderscoreEmphasis);
        useMdCompiler = false;
    } else {
        html = mdCompilerOutput;
    }
} else {
    html = filterMarkdown(md, MarkdownFlags.disableUnderscoreEmphasis);
}
f.writeln(html);

f.writeln("<ul id=\"contents\">");
foreach (c; p.chapters) {
    f.writeln("<li>" ~ c.num() ~ ". <a class=\"chapter-contents-todo\" href=\"" ~ stripExtension(baseName(c.file)) ~ ".html\">" ~ c.title ~ "</a></li>");
}

f.writeln("
</ul>
</div>
</body>
");

f.close();
---

@s Root block check

We check if the block is a root code block. We check this using
a regex that basically checks if it the name has an extension. Additionally,
users can put the block name in quotes to force it to be a root block.

If the block name is in quotes, we have to make sure to remove those once
we're done.

--- Check if it's a root block
auto fileMatch = matchAll(block.name, regex(".*\\.\\w+"));
auto quoteMatch = matchAll(block.name, regex("^\".*\"$"));
if (fileMatch || quoteMatch) {
    block.isRootBlock = true;
    if (quoteMatch) {
        block.name = block.name[1..$-1];
    }
}
---

@s WeaveChapter

This function weaves a single chapter.

--- WeaveChapter
string weaveChapter(Chapter c, Program p, string[string] defLocations,
                    string[][string] redefLocations, string[][string] addLocations,
                    string[][string] useLocations) {
@{prettify}
@{css}
@{katex}

    string output = "";

    @{Write the head of the HTML}
    @{Write the body}

    if (use_katex) {
@{Write the katex source}
    }

    if (isBook) {
        output ~= "<br>";
        int index = cast(int) p.chapters.countUntil(c);
        if (index - 1 >= 0) {
            Chapter lastChapter = p.chapters[p.chapters.countUntil(c)-1];
            output ~= "<a style=\"float:left;\" class=\"chapter-nav\" href=\"" ~ stripExtension(baseName(lastChapter.file)) ~ ".html\">Previous Chapter</a>";
        }
        if (index + 1 < p.chapters.length) {
            Chapter nextChapter = p.chapters[p.chapters.countUntil(c)+1];
            output ~= "<a style=\"float:right;\" class=\"chapter-nav\" href=\"" ~ stripExtension(baseName(nextChapter.file)) ~ ".html\">Next Chapter</a>";
        }
    }

    output ~= "</body>\n";

    return output;
}
---

@s Head of the Document

This writes out the start of the document. Mainly the scripts (prettify.js) 
and the css (prettiy css, default css, and colorscheme css). It also adds
the title of the document.

--- Write the head of the HTML
string prettifyExtension;
foreach (cmd; p.commands) {
    if (cmd.name == "@overwrite_css") {
        defaultCSS = readall(File(cmd.args));
    } else if (cmd.name == "@add_css") {
        defaultCSS ~= readall(File(cmd.args));
    } else if (cmd.name == "@colorscheme") {
        colorschemeCSS = readall(File(cmd.args));
    }

    if (cmd.name == "@code_type") {
        if (cmd.args.length > 1) {
            string ext = cmd.args.split()[1][1..$];
            if (ext in extensions) {
                prettifyExtension = "<script>\n" ~ extensions[ext] ~ "</script>\n";
            }
        }
    }
}
foreach (cmd; c.commands) {
    if (cmd.name == "@overwrite_css") {
        defaultCSS = readall(File(cmd.args));
    } else if (cmd.name == "@add_css") {
        defaultCSS ~= readall(File(cmd.args));
    } else if (cmd.name == "@colorscheme") {
        colorschemeCSS = readall(File(cmd.args));
    }

    if (cmd.name == "@code_type") {
        if (cmd.args.length > 1) {
            string ext = cmd.args.split()[1][1..$];
            if (ext in extensions) {
                prettifyExtension = "<script>\n" ~ extensions[ext] ~ "</script>\n";
            }
        }
    }
}

string css = colorschemeCSS ~ defaultCSS;
string scripts = "<script>\n" ~ prettify ~ "</script>\n";
scripts ~= prettifyExtension;

bool use_katex = false;

output ~= "<!DOCTYPE html>\n" ~
             "<html>\n" ~
             "<head>\n" ~
             "<meta charset=\"utf-8\">\n" ~
             "<title>" ~ c.title ~ "</title>\n" ~
             scripts ~
             "<style>\n" ~
             css ~
             "</style>\n" ~
             "</head>\n";
---

@s Parse the Chapter

Now we write the body -- this is the meat of the weaver. First we write
a couple things at the beginning: making sure the `prettyprint` function is
called when the page loads, and writing out the title as an `h1`.

Then we loop through each section in the chapter. At the beginning of each section,
we write the title, and an empty `a` link so that the section title can be linked to.
We also have to determine if the section title should be a `noheading` class. If the
section title is empty, then the class should be `noheading` which means that the prose
will be moved up a bit towards it -- otherwise it looks like there is too much empty space
between the title and the prose.

--- Write the body
output ~= "<body onload=\"prettyPrint()\">\n" ~
          "<section>\n" ~
          "<h1>" ~ c.title ~ "</h1>\n";

foreach (s; c.sections) {
    string noheading = s.title == "" ? " class=\"noheading\"" : "";
    output ~= "<a name=\"" ~ c.num() ~ ":" ~ to!string(s.num) ~ "\"><div class=\"section\"><h" ~ 
              to!string(sectionDepth) ~ noheading ~ ">" ~ to!string(s.num) ~ ". " ~ s.title ~ 
              "</h" ~ to!string(sectionDepth) ~ "></a>\n";

    foreach (block; s.blocks) {
        if (!block.modifiers.canFind(Modifier.noWeave)) {
            if (!block.isCodeblock) {
                @{Weave a prose block}
            } else {
                @{Weave a code block}
            }
        }
    }
    output ~= "</div>\n";
}
---

@s Weave a prose block

Weaving a prose block is not very complicated. First we get the html by sending it
through the markdown compiler by using the `filterMarkdown` function. We disable the
use of underscores for italics because that interferes with the katex use of underscores
for math.

Then use a giant regex to determine if any katex is being used. Really what that regex does
is determine if there is something in dollar signs or double dollar signs which aren't escaped
by backslashes. Most of the regex is negative look behind to make sure the dollar sign isn't
escaped.

--- Weave a prose block
string html;

string md = "";

foreach (lineObj; block.lines) {
    auto l = lineObj.text;
    if (l.matchAll(regex(r"@\{.*?\}"))) {
        auto matches = l.matchAll(regex(r"@\{(.*?)\}"));
        foreach (m; matches) {
            auto def = "";
            auto defLocation = "";
            auto str = strip(m[1]);
            if (str !in defLocations) {
                error(lineObj.file, lineObj.lineNum, "{" ~ str ~ "} is never defined");
            } else if (defLocations[str] != "noWeave") {
                def = defLocations[str];
                defLocation = def;
                auto index = def.indexOf(":");
                string chapter = def[0..index];
                auto htmlFile = getChapterHtmlFile(p.chapters, chapter);
                if (chapter == c.num()) {
                    defLocation = def[index + 1..$];
                }
                l = l.replaceAll(regex(r"@\{" ~ str ~ r"\}"), "`{" ~ str ~ ",`[`" ~ defLocation ~ "`](" ~ htmlFile ~ "#" ~ def ~ ")`}`");
            }
        }
    }
    md ~= l ~ "\n";
}

if (md.matchAll(regex(r"(?<!\\)[\$](?<!\\)[\$](.*?)(?<!\\)[\$](?<!\\)[\$]")) || md.matchAll(regex(r"(?<!\\)[\$](.*?)(?<!\\)[\$]"))) {
    use_katex = true;
}

md = md.replaceAll(regex(r"(?<!\\)[\$](?<!\\)[\$](.*?)(?<!\\)[\$](?<!\\)[\$]", "s"), "<div class=\"math\">$1</div>");
md = md.replaceAll(regex(r"(?<!\\)[\$](.*?)(?<!\\)[\$]", "s"), "<span class=\"math\">$1</span>");
md = md.replaceAll(regex(r"\\\$"), "$$");


if (useMdCompiler) {
    auto pipes = pipeShell(mdCompilerCmd, Redirect.stdin | Redirect.stdout | Redirect.stderrToStdout);
    pipes.stdin.write(md);
    pipes.stdin.flush();
    pipes.stdin.close();
    auto status = wait(pipes.pid);
    string mdCompilerOutput;
    foreach (line; pipes.stdout.byLine) mdCompilerOutput ~= line.idup;
    if (status != 0) {
        warn(c.file, 1, "Custom markdown compilation failed: " ~ mdCompilerOutput ~ " -- Falling back to built-in markdown compiler");
        html = filterMarkdown(md, MarkdownFlags.disableUnderscoreEmphasis);
        useMdCompiler = false;
    } else {
        html = mdCompilerOutput;
    }
} else {
    html = filterMarkdown(md, MarkdownFlags.disableUnderscoreEmphasis);
}
---

Here we use the same regex to actually perform the substitution. Double dollars mean a block math
which means we have to use a div. For inline math (single dollars) we use a span. After that substitution
we replace all backslash dollars to real dollar signs.

Finally we add this html to the output and add a newline for good measure.

--- Weave a prose block +=
output ~= html ~ "\n";
---

@s Weave a code block

--- Weave a code block
output ~= "<div class=\"codeblock\">\n";

@{Write the title out}
@{Write the actual code}
@{Write the 'added to' links}
@{Write the 'redefined in' links}
@{Write the 'used in' links}

output ~= "</div>\n";
---

@s The codeblock title

Here we create the title for the codeblock. For the title, we have to link
to the definition (which is usually the current block, but sometimes not
because of `+=`). We also need to make the title bold (`<strong>`) if it
is a root code block.

--- Write the title out
@{Find the definition location}
@{Make the title bold if necessary}

output ~= "<span class=\"codeblock_name codeblock-def\">{" ~ name ~ 
          " <a href=\"" ~ htmlFile ~ "#" ~ def ~ "\">" ~ defLocation ~ "</a>}" ~ extra ~ "</span>\n";
---

To find the definition location we use the handy `defLocation` array that we made
earlier. The reason we have both the variables `def` and `defLocation` is because
the definition location might be in another chapter, in which case it should be
displayed as `chapterNum:sectionNum` but if it's in the current file, the `chapterNum`
can be removed. `def` gives us the real definition location, and `defLocation` is the
one that will be used -- it strips out the `chapterNum` if necessary.

--- Find the definition location
string chapterNum;
string def;
string defLocation;
string htmlFile = "";
if (block.name !in defLocations) {
    error(block.startLine.file, block.startLine.lineNum, "{" ~ block.name ~ "} is never defined");
} else {
    def = defLocations[block.name];
    defLocation = def;
    auto index = def.indexOf(":");
    string chapter = def[0..index];
    htmlFile = getChapterHtmlFile(p.chapters, chapter);
    if (chapter == c.num()) {
        defLocation = def[index + 1..$];
    }
}
---

We also add the `+=` or `:=` if necessary. This needs to be the `extra` because
it goes outside the `{}` and is not really part of the name anymore.

--- Find the definition location +=
string extra = "";
if (block.modifiers.canFind(Modifier.additive)) {
    extra = " +=";
} else if (block.modifiers.canFind(Modifier.redef)) {
    extra = " :=";
}
---

We simple put the title in in a strong tag if it is a root codeblock to make it bold.

--- Make the title bold if necessary
string name;
if (block.isRootBlock) {
    name = "<strong>" ~ block.name ~ "</strong>";
} else {
    name = block.name;
}
---

@s The actual code

At the beginning, we open the pre tag. If a codetype is defined, we tell the prettyprinter
to use that, otherwise, the pretty printer will try to figure out how to syntax highlight
on its own -- and it's pretty good at that.

--- Write the actual code
if (block.codeType.split().length > 1) {
    if (block.codeType.split()[1].indexOf(".") == -1) {
        warn(block.startLine.file, 1, "@code_type extension must begin with a '.', for example: `@code_type c .c`");
    } else {
        output ~= "<pre class=\"prettyprint lang-" ~ block.codeType.split()[1][1..$] ~ "\">\n";
    }
} else {
    output ~= "<pre class=\"prettyprint\">\n";
}

foreach (lineObj; block.lines) {
    @{Write the line}
}
output ~= "</pre>\n";
---

Now we loop through each line. The only complicated thing here is if the line is
a codeblock use. Then we have to link to the correct definition location.

Also we escape all ampersands and greater than and less than signs before writing them.

--- Write the line
string line = lineObj.text;
string strippedLine = strip(line);
if (strippedLine.startsWith("@{") && strippedLine.endsWith("}")) {
    @{Link a used codeblock}
} else { 
    output ~= line.replace("&", "&amp;").replace(">", "&gt;").replace("<", "&lt;") ~ "\n";
}
---

For linking the used codeblock, it's pretty much the same deal as before. We
reuse the `def` and `defLocation` variables. We also write the final html as
a span with the `nocode` class, that way it won't be syntax highlighted by the
pretty printer.

--- Link a used codeblock
def = "";
defLocation = "";
if (strip(strippedLine[2..$ - 1]) !in defLocations) {
    error(lineObj.file, lineObj.lineNum, "{" ~ strip(strippedLine[2..$ - 1]) ~ "} is never defined");
} else if (defLocations[strip(strippedLine[2..$ - 1])] != "noWeave") {
    def = defLocations[strippedLine[2..$ - 1]];
    defLocation = def;
    auto index = def.indexOf(":");
    string chapter = def[0..index];
    htmlFile = getChapterHtmlFile(p.chapters, chapter);
    if (chapter == c.num()) {
        defLocation = def[index + 1..$];
    }
    def = ", <a class=\"codeblock-ref ref-to-usage\" href=\"" ~ htmlFile ~ "#" ~ def ~ "\">" ~ defLocation ~ "</a>";
}
output ~= "<span class=\"nocode pln\">" ~ leadingWS(line) ~ "{" ~ strippedLine[2..$ - 1] ~ def ~ "}</span>\n";
---

@s Add links to other sections

Writing the links is pretty similar to figuring out where a codeblock
was defined because we have access to the `sectionLocations` array (which is
`addLocations`, `useLocations`, or `redefLocations`). Then we just
have a few if statements to figure out the grammar -- where to put the `and`
and whether to have plurals and whatnot.

--- LinkLocations function
enum ReferenceType {
    AddedTo,
    UsedIn,
    RedefinedIn
}

string getReferenceText(ReferenceType refType) {
    final switch (refType) {
        case ReferenceType.AddedTo:
            return "Added to in section";
        case ReferenceType.UsedIn:
            return "Used in section";
        case ReferenceType.RedefinedIn:
            return "Redefined in section";
    }
}

string getReferenceClass(ReferenceType refType) {
    final switch (refType) {
        case ReferenceType.AddedTo:
            return "codeblock-ref ref-to-append-definition";
        case ReferenceType.UsedIn:
            return "codeblock-ref ref-to-usage";
        case ReferenceType.RedefinedIn:
            return "codeblock-ref ref-to-override-definition";
    }
}

T[] noDupes(T)(in T[] s) {
    import std.algorithm: canFind;
    T[] result;
    foreach (T c; s)
        if (!result.canFind(c))
            result ~= c;
    return result;
}


string linkLocations(ReferenceType refType, string[][string] sectionLocations, Program p, Chapter c, Section s, parser.Block block) {
    if (block.name in sectionLocations) {
        string[] locations = dup(sectionLocations[block.name]).noDupes;

        if (locations.canFind(c.num() ~ ":" ~ to!string(s.num))) {
            locations = remove(locations, locations.countUntil(c.num() ~ ":" ~ to!string(s.num)));
        }

        if (locations.length > 0) {
            string seealso = "<p class=\"seealso\">" ~ getReferenceText(refType);

            if (locations.length > 1) {
                seealso ~= "s ";
            } else {
                seealso ~= " ";
            }

            foreach (i; 0 .. locations.length) {
                string loc = locations[i];
                string locName = loc;
                auto index = loc.indexOf(":");
                string chapter = loc[0..index];
                string htmlFile = getChapterHtmlFile(p.chapters, chapter);
                if (chapter == c.num()) {
                    locName = loc[index + 1..$];
                }
                loc = "<a class=\"" ~ getReferenceClass(refType) ~ "\" href=\"" ~ htmlFile ~ "#" ~ loc ~ "\">" ~ locName ~ "</a>";
                if (i == 0) {
                    seealso ~= loc;
                } else if (i == locations.length - 1) {
                    seealso ~= " and " ~ loc;
                } else {
                    seealso ~= ", " ~ loc;
                }
            }
            seealso ~= "</p>";
            return seealso;
        }
    }
    return "";
}
---

@s See also links

Writing the 'added to' links is pretty similar to figuring out where a codeblock
was defined because we have access to the `addLocations` array. Then we just
have a few if statements to figure out the grammar -- where to put the `and`
and whether to have plurals and whatnot.

--- Write the 'added to' links
output ~= linkLocations(ReferenceType.AddedTo, addLocations, p, c, s, block) ~ "\n";
---

@s Also used in links

This is pretty much the same as the 'added to' links except we use the
`useLocations` array.

--- Write the 'used in' links
output ~= linkLocations(ReferenceType.UsedIn, useLocations, p, c, s, block) ~ "\n";
---

@s Redefined in links

--- Write the 'redefined in' links
output ~= linkLocations(ReferenceType.RedefinedIn, redefLocations, p, c, s, block) ~ "\n";
---

@include weaver_static/weaver_js.lit